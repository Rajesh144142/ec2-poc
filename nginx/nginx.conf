# ============================================================================
# NGINX CONFIGURATION FILE
# ============================================================================
# This file configures Nginx as a reverse proxy for the Node.js API
# Nginx listens on port 80 and forwards requests to the API container
# ============================================================================

# ----------------------------------------------------------------------------
# EVENTS BLOCK
# ----------------------------------------------------------------------------
# Configures how Nginx handles connections
events {
    # Maximum number of simultaneous connections per worker process
    # Each connection can handle multiple requests (keep-alive)
    worker_connections 1024;
}

# ----------------------------------------------------------------------------
# HTTP BLOCK
# ----------------------------------------------------------------------------
# Main configuration block for HTTP server settings
http {
    # ------------------------------------------------------------------------
    # RATE LIMITING CONFIGURATION
    # ------------------------------------------------------------------------
    # Defines a shared memory zone to track request rates per IP address
    # This prevents abuse and DDoS attacks
    #
    # Parameters:
    #   $binary_remote_addr - Client's IP address (binary format, more efficient)
    #   zone=api_limit:10m - Zone name "api_limit" with 10MB memory allocation
    #                        (can track ~160,000 IPs with 10MB)
    #   rate=10r/s - Maximum 10 requests per second per IP address
    #
    # Example: If an IP sends 15 requests/second, 5 will be rejected
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;

    # ------------------------------------------------------------------------
    # UPSTREAM SERVER CONFIGURATION
    # ------------------------------------------------------------------------
    # Defines the backend server(s) that Nginx will proxy requests to
    # "api" is the service name from docker-compose.yml
    upstream api {
        # Points to the API container on port 3000
        # Docker Compose creates a network where containers can communicate
        # by service name (e.g., "api" resolves to the API container's IP)
        server api:3000;
        
        # For load balancing with multiple API instances, you could add:
        # server api:3000 weight=1;
        # server api2:3000 weight=1;
    }

    # ------------------------------------------------------------------------
    # SERVER BLOCK
    # ------------------------------------------------------------------------
    # Defines a virtual server that listens on a specific port
    server {
        # Listen on port 80 (HTTP) on all network interfaces
        # Port 80 is the standard HTTP port
        listen 80;
        
        # Server name - "_" means accept requests for any domain name
        # In production, you might use: server_name example.com www.example.com;
        server_name _;

        # Maximum size of client request body (for file uploads)
        # 10M = 10 megabytes
        # Requests larger than this will return 413 (Request Entity Too Large)
        client_max_body_size 10M;

        # --------------------------------------------------------------------
        # LOCATION BLOCK - Root Path (/)
        # --------------------------------------------------------------------
        # Handles all requests that don't match more specific location blocks
        location / {
            # -----------------------------------------------------------------
            # RATE LIMITING APPLICATION
            # -----------------------------------------------------------------
            # Applies the rate limiting zone defined above
            #
            # Parameters:
            #   zone=api_limit - Use the rate limiting zone we defined
            #   burst=20 - Allow up to 20 extra requests in a burst
            #             (handles traffic spikes gracefully)
            #   nodelay - Don't delay requests, reject immediately if over limit
            #
            # Behavior:
            #   - Normal: 10 requests/second allowed
            #   - Burst: Up to 20 additional requests queued
            #   - Over limit: Returns 503 (Service Unavailable) or 429
            limit_req zone=api_limit burst=20 nodelay;
            
            # -----------------------------------------------------------------
            # SECURITY HEADERS
            # -----------------------------------------------------------------
            # These headers help protect against common web vulnerabilities
            
            # Prevents the page from being embedded in an iframe
            # "SAMEORIGIN" allows embedding only from the same domain
            # Protects against clickjacking attacks
            add_header X-Frame-Options "SAMEORIGIN" always;
            
            # Prevents browsers from MIME-sniffing (guessing content type)
            # Forces browser to use the declared Content-Type
            # Protects against MIME type confusion attacks
            add_header X-Content-Type-Options "nosniff" always;
            
            # Enables browser's built-in XSS (Cross-Site Scripting) filter
            # "1; mode=block" blocks the page if XSS is detected
            # Note: Modern browsers rely more on Content-Security-Policy
            add_header X-XSS-Protection "1; mode=block" always;
            
            # -----------------------------------------------------------------
            # REVERSE PROXY CONFIGURATION
            # -----------------------------------------------------------------
            # Forwards requests to the upstream API server
            
            # Forward all requests to the "api" upstream server
            # http://api resolves to api:3000 (from upstream block above)
            proxy_pass http://api;
            
            # Use HTTP/1.1 protocol (required for some features like keep-alive)
            proxy_http_version 1.1;
            
            # -----------------------------------------------------------------
            # PROXY HEADERS
            # -----------------------------------------------------------------
            # These headers preserve client information and enable features
            
            # Preserve the Upgrade header (for WebSocket support)
            # Allows upgrading HTTP connection to WebSocket if needed
            proxy_set_header Upgrade $http_upgrade;
            
            # Set connection type (needed for WebSocket upgrades)
            proxy_set_header Connection 'upgrade';
            
            # Forward the original Host header from client request
            # API can see the original domain name requested
            proxy_set_header Host $host;
            
            # Forward the real client IP address
            # Without this, API would only see Nginx's IP
            proxy_set_header X-Real-IP $remote_addr;
            
            # Forward the chain of proxy IPs (for when behind multiple proxies)
            # Builds a list: client_ip, proxy1_ip, proxy2_ip, ...
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            
            # Forward the original protocol (http or https)
            # API knows if request was originally HTTPS
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Bypass cache for upgrade requests (WebSocket, etc.)
            # Ensures upgrade requests aren't cached
            proxy_cache_bypass $http_upgrade;
        }
    }
}